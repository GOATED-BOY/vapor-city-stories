!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vapor City Stories - GTA Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; user-select: none; }
        canvas { display: block; }
        
        /* HUD */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #hud-top-right { position: absolute; top: 20px; right: 20px; text-align: right; }
        .hud-box { background: rgba(0,0,0,0.6); color: #fff; padding: 8px 15px; border-radius: 4px; margin-bottom: 5px; border-right: 4px solid #ff00cc; font-weight: bold;}
        .money { color: #00ff00; font-size: 24px; }
        .wanted { color: #ff4444; font-size: 20px; letter-spacing: 3px; }
        
        #hud-bottom-left { position: absolute; bottom: 20px; left: 20px; width: 200px; }
        .bar-bg { width: 100%; height: 10px; background: #333; margin-bottom: 5px; border: 1px solid #000; }
        .health-bar { height: 100%; background: #ff3333; width: 100%; transition: width 0.2s; }
        
        #controls-hint { 
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); 
            color: white; font-size: 16px; font-weight:bold; text-transform: uppercase;
            background:rgba(0,0,0,0.7); padding:8px 16px; border-radius:20px; border: 1px solid #fff;
            opacity: 0; transition: opacity 0.2s;
        }

        /* INVENTORY */
        #inventory-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px;
        }
        .inv-slot {
            width: 40px; height: 40px; background: rgba(0,0,0,0.7); border: 2px solid #555;
            color: #888; font-size: 10px; display: flex; justify-content: center; align-items: center;
            font-weight: bold; border-radius: 4px;
        }
        .inv-slot.owned { color: white; border-color: #999; }
        .inv-slot.active { border-color: #ff00cc; background: rgba(255, 0, 204, 0.2); transform: scale(1.1); color: #fff; }

        /* SHOP */
        #shop-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(15, 15, 20, 0.95); padding: 0; border: 2px solid #00aaff;
            color: white; display: none; pointer-events: auto; 
            border-radius: 8px; width: 350px; max-height: 70vh; overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.3);
        }
        .shop-header { padding: 15px; background: #00aaff; color: #000; font-weight: bold; text-align: center; font-size: 20px; }
        .shop-item {
            display: flex; justify-content: space-between; padding: 12px 20px; border-bottom: 1px solid #333;
            cursor: pointer; transition: 0.2s;
        }
        .shop-item:hover { background: #333; }
        .shop-price { color: #00ff00; font-family: monospace; }

        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: white; }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: white; }

        #intro-screen, #wasted-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #2b1055, #000);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all; color: white;
        }
        #wasted-screen { background: rgba(50, 0, 0, 0.9); display: none; z-index: 200; }
        .wasted-text { color: #ff0000; font-size: 80px; font-family: Impact, sans-serif; text-shadow: 4px 4px 0 #000; letter-spacing: 5px; margin-bottom: 20px;}
        
        .btn { padding: 15px 40px; font-size: 20px; background: #ff00cc; color: white; border: none; cursor: pointer; margin-top: 20px; font-weight: bold; border: 2px solid white; }
        .btn:hover { background: #fff; color: #ff00cc; }
    </style>
</head>
<body>

    <!-- Intro -->
    <div id="intro-screen">
        <h1 style="font-size: 60px; text-shadow: 4px 4px #ff00cc; margin-bottom: 10px; font-style: italic;">VAPOR CITY STORIES</h1>
        <div style="background: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px; text-align: center;">
            <p><b>WASD</b> Move • <b>SPACE</b> Jump • <b>SHIFT</b> Sprint</p>
            <p><b>MOUSE</b> Aim • <b>L-CLICK</b> Shoot</p>
            <p><b>E</b> Interact (Cars, Loot, Shop)</p>
        </div>
        <button class="btn" onclick="startGame()">ENTER CITY</button>
    </div>

    <!-- Wasted -->
    <div id="wasted-screen">
        <div class="wasted-text">WASTED</div>
        <button class="btn" onclick="resetGame()">RESPAWN</button>
    </div>

    <!-- Shop -->
    <div id="shop-overlay">
        <div class="shop-header">AMMUNATION</div>
        <div id="shop-items"></div>
        <div style="text-align: center; padding: 10px;"><button class="btn" style="padding: 5px 20px; font-size: 14px;" onclick="closeShop()">CLOSE</button></div>
    </div>

    <!-- HUD -->
    <div id="ui-layer" style="display:none;">
        <div id="crosshair"></div>
        <div id="controls-hint"></div>
        
        <div id="hud-top-right">
            <div class="hud-box"><span class="money" id="money-display">$100</span></div>
            <div class="hud-box"><div class="wanted" id="wanted-display">☆☆☆☆☆</div></div>
            <div class="hud-box" id="weapon-name">PISTOL</div>
        </div>

        <div id="hud-bottom-left">
            <div class="bar-bg"><div class="health-bar" id="health-bar"></div></div>
        </div>

        <div id="inventory-bar"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            gravity: 0.6,
            walkSpeed: 0.35,
            runSpeed: 0.7,
            jumpForce: 1.1,
            mouseSensitivity: 0.002,
            worldSize: 60
        };

        // --- WEAPONS ---
        const WEAPONS = [
            { name: 'Pistol', damage: 25, rate: 0.4, range: 80, spread: 0.02, price: 0, color: 0x999999, modelType: 'pistol' },
            { name: 'Uzi', damage: 12, rate: 0.08, range: 50, spread: 0.1, price: 800, color: 0x333333, modelType: 'smg' },
            { name: 'Shotgun', damage: 15, rate: 0.8, range: 30, spread: 0.25, pellets: 6, price: 1500, color: 0x552200, modelType: 'heavy' },
            { name: 'AK-47', damage: 35, rate: 0.12, range: 120, spread: 0.04, price: 3000, color: 0x8B4513, modelType: 'rifle' },
            { name: 'M4', damage: 30, rate: 0.09, range: 130, spread: 0.02, price: 4500, color: 0x111111, modelType: 'rifle' },
            { name: 'Sniper', damage: 95, rate: 1.2, range: 300, spread: 0.001, price: 7000, color: 0x222222, modelType: 'long' },
            { name: 'Minigun', damage: 10, rate: 0.04, range: 80, spread: 0.15, price: 12000, color: 0x555555, modelType: 'heavy' },
            { name: 'RPG', damage: 150, rate: 1.5, range: 150, spread: 0.05, price: 20000, color: 0x225522, explosive: true, modelType: 'heavy' }
        ];

        const STATE = {
            isPlaying: false,
            money: 100,
            health: 100,
            wantedLevel: 0,
            inVehicle: false,
            currentVehicle: null,
            currentWeapon: 0,
            lastShotTime: 0,
            ownedWeapons: [0],
            shopOpen: false
        };

        // --- ENGINE ---
        let scene, camera, renderer, clock;
        let player, cityGroup = new THREE.Group(), npcGroup = new THREE.Group();
        let interactables = [], zones = [], colliders = [];
        let legAnims = [];
        const inputs = { w: false, a: false, s: false, d: false, space: false, shift: false, mouse: false, e: false };
        let interactDebounce = false;

        // --- TEXTURE GEN ---
        function createBuildingTexture(type) {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            ctx.fillStyle = type === 'downtown' ? '#445566' : (type === 'ind' ? '#553322' : '#ccbb99');
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = Math.random()>0.5 ? '#ffffaa' : '#111';
            for(let y=8; y<64; y+=16) for(let x=8; x<64; x+=16) ctx.fillRect(x,y,8,10);
            const tex = new THREE.CanvasTexture(c); tex.magFilter = THREE.NearestFilter; return tex;
        }

        function createRoadTexture() {
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#333'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#e3e300';
            ctx.fillRect(60, 0, 8, 40); 
            ctx.fillRect(60, 64, 8, 40);
            const tex = new THREE.CanvasTexture(c); 
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x201040);
            scene.fog = new THREE.FogExp2(0x201040, 0.005);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x808080));
            const sun = new THREE.DirectionalLight(0xffcc00, 1.2);
            sun.position.set(100, 100, 50); sun.castShadow = true;
            scene.add(sun);

            clock = new THREE.Clock();

            generateCity();
            setupPlayer();
            setupNPCs();
            setupTraffic();
            setupShops();
            
            scene.add(cityGroup);
            scene.add(npcGroup);

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => { if(!STATE.shopOpen) inputs.mouse = true; });
            document.addEventListener('mouseup', () => inputs.mouse = false);
            document.addEventListener('mousemove', onMouseMove);

            generateInventoryUI();
            animate();
        }

        // --- CITY GEN ---
        function generateCity() {
            const texDowntown = createBuildingTexture('downtown');
            const texInd = createBuildingTexture('ind');
            const texSub = createBuildingTexture('sub');
            const texRoad = createRoadTexture(); 

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshStandardMaterial({color: 0x111111}));
            ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; cityGroup.add(ground);

            const water = new THREE.Mesh(new THREE.PlaneGeometry(1000, 3000), new THREE.MeshBasicMaterial({color: 0x0044aa, transparent:true, opacity:0.8}));
            water.rotation.x = -Math.PI/2; water.position.set(900, -0.5, 0); cityGroup.add(water);
            const sand = new THREE.Mesh(new THREE.PlaneGeometry(200, 3000), new THREE.MeshBasicMaterial({color: 0xddbb88}));
            sand.rotation.x = -Math.PI/2; sand.position.set(500, 0.02, 0); cityGroup.add(sand);

            const geoBlock = new THREE.BoxGeometry(1,1,1);
            const geoRoad = new THREE.PlaneGeometry(20,20);
            const matRoad = new THREE.MeshStandardMaterial({map: texRoad}); 

            const r = CONFIG.worldSize / 2;
            
            for(let x = -r; x < r; x++) {
                for(let z = -r; z < r; z++) {
                    const px = x * 20;
                    const pz = z * 20;
                    if (px > 400) continue; 

                    let type = 'downtown';
                    if (pz < -200) type = 'ind';
                    else if (pz > 200) type = 'sub';

                    if (x%3===0 || z%3===0) {
                        const road = new THREE.Mesh(geoRoad, matRoad);
                        road.rotation.x = -Math.PI/2;
                        road.position.set(px, 0.05, pz);
                        road.receiveShadow = true;
                        cityGroup.add(road);
                    } else {
                        let h = 20;
                        let mat = new THREE.MeshStandardMaterial({map: texDowntown});
                        if(type === 'downtown') h = 30 + Math.random()*50;
                        if(type === 'ind') { h = 15 + Math.random()*20; mat = new THREE.MeshStandardMaterial({map: texInd}); }
                        if(type === 'sub') { h = 10 + Math.random()*10; mat = new THREE.MeshStandardMaterial({map: texSub}); }

                        const b = new THREE.Mesh(geoBlock, mat);
                        b.position.set(px, h/2, pz);
                        b.scale.set(18, h, 18); 
                        b.castShadow = true; b.receiveShadow = true;
                        cityGroup.add(b);
                        
                        const box = new THREE.Box3().setFromObject(b);
                        box.expandByScalar(-0.5);
                        colliders.push(box);
                    }
                }
            }
        }

        function setupShops() {
            createShopModel(10, 0, 0x0000ff, "GUNS", 'gunshop');
        }

        function createShopModel(x, z, color, label, type) {
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            const wall = new THREE.Mesh(new THREE.BoxGeometry(12, 6, 12), new THREE.MeshStandardMaterial({color: color}));
            wall.position.y = 3;
            const door = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 1), new THREE.MeshBasicMaterial({color: 0x000000}));
            door.position.set(0, 2, 6);
            g.add(wall, door);
            scene.add(g);
            colliders.push(new THREE.Box3().setFromObject(wall)); 
            zones.push({type: type, pos: new THREE.Vector3(x, 0, z + 8)}); 
        }

        // --- ENTITIES ---
        function createCharModel(colorSkin, colorShirt, colorPants) {
            const g = new THREE.Group();
            const matSkin = new THREE.MeshStandardMaterial({color: colorSkin});
            const matShirt = new THREE.MeshStandardMaterial({color: colorShirt});
            const matPants = new THREE.MeshStandardMaterial({color: colorPants});

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin); head.position.y = 1.7;
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.3), matShirt); body.position.y = 1.15;
            
            const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matPants); lLeg.position.set(-0.2, 0.4, 0);
            const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matPants); rLeg.position.set(0.2, 0.4, 0);
            
            const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matSkin); lArm.position.set(-0.45, 1.15, 0);
            const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matSkin); rArm.position.set(0.45, 1.15, 0); rArm.name = 'rArm';

            g.add(head, body, lLeg, rLeg, lArm, rArm);
            g.userData = { legs: [lLeg, rLeg] };
            return g;
        }

        function setupPlayer() {
            player = createCharModel(0xffccaa, 0x00aaff, 0x222222);
            scene.add(player);
            player.position.set(0, 5, 20);
            
            player.armGroup = new THREE.Group();
            player.armGroup.position.set(0.45, 1.15, 0);
            player.add(player.armGroup);
            
            player.getObjectByName('rArm').visible = false;
            const visArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), new THREE.MeshStandardMaterial({color: 0xffccaa}));
            visArm.rotation.x = -Math.PI/2; visArm.position.z = 0.35;
            player.armGroup.add(visArm);

            player.vel = new THREE.Vector3();
            player.onGround = false;
            player.rotY = 0; player.pitch = 0;
            
            updatePlayerGun();
        }

        function updatePlayerGun() {
            if(player.gun) player.armGroup.remove(player.gun);
            const w = WEAPONS[STATE.currentWeapon];
            
            let geo;
            if(w.modelType === 'pistol') geo = new THREE.BoxGeometry(0.1, 0.15, 0.3);
            else if(w.modelType === 'rifle') geo = new THREE.BoxGeometry(0.1, 0.15, 0.8);
            else geo = new THREE.BoxGeometry(0.15, 0.15, 0.6);

            player.gun = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: w.color}));
            player.gun.position.set(0, -0.1, 0.7);
            player.armGroup.add(player.gun);
            document.getElementById('weapon-name').innerText = w.name.toUpperCase();
        }

        function setupNPCs() {
            for(let i=0; i<40; i++) {
                const npc = createCharModel(0xffccaa, Math.random()*0xffffff, 0x111111);
                npc.position.set((Math.random()*200)-100, 0, (Math.random()*200)-100);
                npc.userData.npcData = {
                    health: 100,
                    state: 'walk',
                    timer: 0,
                    dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize()
                };
                npcGroup.add(npc);
            }
        }

        function setupTraffic() {
            for(let i=0; i<30; i++) {
                const car = new THREE.Group();
                const col = Math.random()*0xffffff;
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 4.5), new THREE.MeshStandardMaterial({color: col})); body.position.y=0.5;
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 2), new THREE.MeshStandardMaterial({color: 0x333})); top.position.set(0, 1.3, -0.5);
                car.add(body, top);
                
                const x = (Math.floor(Math.random()*10)-5) * 20; 
                car.position.set(x, 0.5, (Math.random()*400)-200);
                car.userData = { type: 'car', speed: 0.2 };
                car.rotation.y = x > 0 ? 0 : Math.PI; 
                
                scene.add(car);
                interactables.push(car);
            }
        }

        // --- UPDATE ---
        function update(dt) {
            if (STATE.inVehicle) {
                const car = STATE.currentVehicle;
                if(inputs.w) car.userData.speed += 10 * dt;
                if(inputs.s) car.userData.speed -= 10 * dt;
                car.userData.speed *= 0.95;
                if(inputs.a) car.rotation.y += 2 * dt;
                if(inputs.d) car.rotation.y -= 2 * dt;
                car.translateZ(car.userData.speed * dt);
                player.position.copy(car.position);
                player.rotY = car.rotation.y;
            } else {
                const speed = inputs.shift ? CONFIG.runSpeed : CONFIG.walkSpeed;
                const dir = new THREE.Vector3();
                if(inputs.w) dir.z -= 1; if(inputs.s) dir.z += 1;
                if(inputs.a) dir.x -= 1; if(inputs.d) dir.x += 1;
                dir.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotY);
                
                if(dir.lengthSq() > 0) {
                    dir.normalize();
                    const next = player.position.clone().addScaledVector(dir, speed);
                    if(!checkWall(next)) player.position.copy(next);
                    
                    const t = clock.getElapsedTime() * 15;
                    player.userData.legs[0].rotation.x = Math.sin(t)*0.5;
                    player.userData.legs[1].rotation.x = Math.cos(t)*0.5;
                } else {
                    player.userData.legs[0].rotation.x = 0;
                    player.userData.legs[1].rotation.x = 0;
                }

                if(!player.onGround) player.vel.y -= CONFIG.gravity * 60 * dt;
                player.position.y += player.vel.y * dt;
                if(player.position.y < 0) { player.position.y=0; player.vel.y=0; player.onGround=true; }
                if(inputs.space && player.onGround) { player.vel.y = 15; player.onGround=false; }
            }

            npcGroup.children.forEach(npc => {
                const data = npc.userData.npcData;
                if(data.health <= 0) return;

                if(data.state === 'attack') {
                    npc.lookAt(player.position.x, npc.position.y, player.position.z);
                    if(npc.position.distanceTo(player.position) > 5) npc.translateZ(5 * dt);
                    data.timer += dt;
                    if(data.timer > 1.0) {
                        data.timer = 0;
                        fireBullet(npc.position.clone().add(new THREE.Vector3(0,1.5,0)), player.position.clone().add(new THREE.Vector3(0,1,0)), 0xff0000);
                        if(Math.random() > 0.5) { STATE.health -= 5; updateHUD(); if(STATE.health<=0) gameOver(); }
                    }
                } else {
                    const next = npc.position.clone().addScaledVector(data.dir, 3 * dt);
                    if(!checkWall(next)) npc.position.copy(next);
                    else data.dir.applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/2);
                    npc.lookAt(npc.position.clone().add(data.dir));
                }
                const t = clock.getElapsedTime()*10 + npc.id;
                npc.userData.legs[0].rotation.x = Math.sin(t)*0.5;
                npc.userData.legs[1].rotation.x = Math.cos(t)*0.5;
            });

            interactables.forEach(obj => {
                if(obj.userData.type === 'car' && obj !== STATE.currentVehicle) {
                    obj.translateZ(10 * dt); 
                    if(obj.position.z > 400) obj.position.z = -400;
                    if(obj.position.z < -400) obj.position.z = 400;
                }
            });

            handleInteractions();

            if(inputs.mouse && !STATE.inVehicle && !STATE.shopOpen) firePlayerWeapon();
        }

        function checkWall(pos) {
            const box = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(0.5, 2, 0.5));
            return colliders.some(c => c.intersectsBox(box));
        }

        function handleInteractions() {
            let hint = "";
            const pPos = player.position;

            zones.forEach(z => {
                if(pPos.distanceTo(z.pos) < 4) {
                    if(z.type === 'gunshop') {
                        hint = "E - OPEN SHOP";
                        if(inputs.e && !interactDebounce) { openShop(); interactDebounce=true; }
                    }
                }
            });

            if(!hint && !STATE.inVehicle) {
                interactables.forEach(obj => {
                    if(pPos.distanceTo(obj.position) < 4) {
                        if(obj.userData.type === 'car') {
                            hint = "E - DRIVE";
                            if(inputs.e && !interactDebounce) {
                                STATE.inVehicle = true;
                                STATE.currentVehicle = obj;
                                player.visible = false;
                                interactDebounce = true;
                            }
                        } else if (obj.userData.type === 'loot') {
                            hint = "E - TAKE CASH";
                            if(inputs.e && !interactDebounce) {
                                STATE.money += obj.userData.val;
                                scene.remove(obj);
                                interactables = interactables.filter(i=>i!==obj);
                                updateHUD();
                                interactDebounce = true;
                            }
                        }
                    }
                });
            } else if (STATE.inVehicle) {
                hint = "E - EXIT";
                if(inputs.e && !interactDebounce) {
                    STATE.inVehicle = false;
                    player.visible = true;
                    player.position.x += 3;
                    STATE.currentVehicle = null;
                    interactDebounce = true;
                }
            }

            const el = document.getElementById('controls-hint');
            el.innerText = hint;
            el.style.opacity = hint ? 1 : 0;
            if(!inputs.e) interactDebounce = false;
        }

        function firePlayerWeapon() {
            const w = WEAPONS[STATE.currentWeapon];
            const now = clock.getElapsedTime();
            if(now - STATE.lastShotTime < w.rate) return;
            STATE.lastShotTime = now;

            player.armGroup.rotation.x = -0.2; 
            setTimeout(()=>player.armGroup.rotation.x = 0, 100);

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(npcGroup.children, true);
            
            let target = player.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100));

            if(hits.length > 0) {
                const hit = hits[0];
                target = hit.point;
                let obj = hit.object;
                while(obj.parent && obj.parent !== npcGroup) obj = obj.parent;
                
                if(obj.userData.npcData) {
                    obj.userData.npcData.health -= w.damage;
                    obj.userData.npcData.state = 'attack'; 
                    obj.children.forEach(c => { if(c.material) c.material.emissive = new THREE.Color(0xff0000); });
                    
                    if(obj.userData.npcData.health <= 0) {
                        obj.rotation.x = -Math.PI/2; obj.position.y = 0.2;
                        spawnLoot(obj.position);
                        STATE.wantedLevel++;
                        updateHUD();
                    }
                }
            }
            fireBullet(player.gun.getWorldPosition(new THREE.Vector3()), target, 0xffff00);
        }

        function fireBullet(start, end, color) {
            const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color: color}));
            scene.add(line);
            setTimeout(() => scene.remove(line), 50);
        }

        function spawnLoot(pos) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.2,0.3), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            m.position.copy(pos); m.position.y = 0.5;
            m.userData = { type: 'loot', val: 50+Math.floor(Math.random()*100) };
            scene.add(m);
            interactables.push(m);
        }

        // --- UI ---
        function openShop() {
            STATE.shopOpen = true;
            document.exitPointerLock();
            const list = document.getElementById('shop-items');
            list.innerHTML = '';
            WEAPONS.forEach((w, i) => {
                const d = document.createElement('div');
                d.className = 'shop-item';
                const owned = STATE.ownedWeapons.includes(i);
                d.innerHTML = `<span>${w.name}</span> <span class="shop-price">${owned ? 'OWNED' : '$'+w.price}</span>`;
                if(!owned) d.onclick = () => buyWeapon(i);
                list.appendChild(d);
            });
            document.getElementById('shop-overlay').style.display = 'block';
        }

        function closeShop() {
            STATE.shopOpen = false;
            document.getElementById('shop-overlay').style.display = 'none';
            document.body.requestPointerLock();
        }

        function buyWeapon(idx) {
            const w = WEAPONS[idx];
            if(STATE.money >= w.price) {
                STATE.money -= w.price;
                STATE.ownedWeapons.push(idx);
                updateHUD();
                generateInventoryUI();
                openShop();
            } else alert("Need Cash!");
        }

        function generateInventoryUI() {
            const el = document.getElementById('inventory-bar');
            el.innerHTML = '';
            WEAPONS.forEach((w, i) => {
                const d = document.createElement('div');
                d.className = 'inv-slot';
                if(STATE.ownedWeapons.includes(i)) d.classList.add('owned');
                if(STATE.currentWeapon === i) d.classList.add('active');
                d.innerText = i+1;
                el.appendChild(d);
            });
        }

        function updateHUD() {
            document.getElementById('money-display').innerText = '$' + STATE.money;
            let s = ""; for(let i=0; i<5; i++) s += i < STATE.wantedLevel ? "★" : "☆";
            document.getElementById('wanted-display').innerText = s;
            document.getElementById('health-bar').style.width = STATE.health + "%";
        }

        function switchWeapon(idx) {
            if(STATE.ownedWeapons.includes(idx)) {
                STATE.currentWeapon = idx;
                updatePlayerGun();
                generateInventoryUI();
            }
        }

        function resetGame() {
            STATE.health = 100;
            STATE.wantedLevel = 0;
            STATE.money = 100;
            
            player.position.set(0, 5, 20);
            player.vel.set(0, 0, 0);
            
            document.getElementById('wasted-screen').style.display = 'none';
            STATE.isPlaying = true;
            document.body.requestPointerLock();
            updateHUD();
        }

        function onKeyDown(e) {
            if(STATE.shopOpen) return;
            const k = e.key.toLowerCase();
            if(inputs.hasOwnProperty(k)) inputs[k] = true;
            if(k === 'shift') inputs.shift = true;
            if(k === ' ') inputs.space = true;
            const n = parseInt(e.key);
            if(n > 0 && n <= WEAPONS.length) switchWeapon(n-1);
        }
        function onKeyUp(e) {
            const k = e.key.toLowerCase();
            if(inputs.hasOwnProperty(k)) inputs[k] = false;
            if(k === 'shift') inputs.shift = false;
            if(k === ' ') inputs.space = false;
        }
        function onMouseMove(e) {
            if(!STATE.shopOpen && document.pointerLockElement) {
                player.rotY -= e.movementX * CONFIG.mouseSensitivity;
                player.pitch -= e.movementY * CONFIG.mouseSensitivity;
                player.pitch = Math.max(-1.5, Math.min(1.5, player.pitch));
            }
        }
        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function gameOver() {
            STATE.isPlaying = false;
            document.getElementById('wasted-screen').style.display = 'flex';
            document.exitPointerLock();
        }

        function animate() {
            requestAnimationFrame(animate);
            if(STATE.isPlaying) {
                const dt = Math.min(clock.getDelta(), 0.1);
                update(dt);
                
                const tgt = STATE.inVehicle ? STATE.currentVehicle.position : player.position;
                const dist = STATE.inVehicle ? 10 : 5;
                const ht = STATE.inVehicle ? 5 : 2.5;
                const cx = tgt.x + Math.sin(player.rotY) * dist;
                const cz = tgt.z + Math.cos(player.rotY) * dist;
                camera.position.lerp(new THREE.Vector3(cx, tgt.y+ht - player.pitch*2, cz), 0.2);
                camera.lookAt(tgt.x, tgt.y + 1.5 + player.pitch, tgt.z);
            }
            renderer.render(scene, camera);
        }

        function startGame() {
            document.getElementById('intro-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            STATE.isPlaying = true;
            document.body.requestPointerLock();
        }

        init();
    </script>
</body>
</html>